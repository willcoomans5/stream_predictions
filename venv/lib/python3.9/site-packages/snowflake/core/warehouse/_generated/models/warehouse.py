# coding: utf-8
"""
    Snowflake Warehouse API

    The Snowflake Warehouse API is a REST API that you can use to access, customize and manage virtual warehouse in a Snowflake account.  # noqa: E501

    The version of the OpenAPI document: 0.0.1
    Contact: support@snowflake.com
    Generated by: https://openapi-generator.tech

    Do not edit this file manually.
"""

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from typing import Union

from datetime import datetime

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator

from typing import Any, ClassVar, Dict, List, Optional

from typing_extensions import Annotated


class Warehouse(BaseModel):

    name: Annotated[str, Field(strict=True)]

    warehouse_type: Optional[StrictStr] = None

    warehouse_size: Optional[StrictStr] = None

    wait_for_completion: Optional[StrictStr] = None

    max_cluster_count: Optional[StrictInt] = None

    min_cluster_count: Optional[StrictInt] = None

    scaling_policy: Optional[StrictStr] = None

    auto_suspend: Optional[StrictInt] = None

    auto_resume: Optional[StrictStr] = None

    initially_suspended: Optional[StrictStr] = None

    resource_monitor: Optional[Annotated[str, Field(strict=True)]] = None

    comment: Optional[StrictStr] = None

    enable_query_acceleration: Optional[StrictStr] = None

    query_acceleration_max_scale_factor: Optional[StrictInt] = None

    max_concurrency_level: Optional[StrictInt] = None

    statement_queued_timeout_in_seconds: Optional[StrictInt] = None

    statement_timeout_in_seconds: Optional[StrictInt] = None

    type: Optional[StrictStr] = None

    size: Optional[StrictStr] = None

    state: Optional[StrictStr] = None

    started_clusters: Optional[StrictInt] = None

    running: Optional[StrictInt] = None

    queued: Optional[StrictInt] = None

    is_default: Optional[StrictBool] = None

    is_current: Optional[StrictBool] = None

    available: Optional[StrictStr] = None

    provisioning: Optional[StrictStr] = None

    quiescing: Optional[StrictStr] = None

    other: Optional[StrictStr] = None

    created_on: Optional[datetime] = None

    resumed_on: Optional[datetime] = None

    updated_on: Optional[datetime] = None

    owner: Optional[StrictStr] = None

    budget: Optional[StrictStr] = None

    kind: Optional[StrictStr] = None

    owner_role_type: Optional[StrictStr] = None

    __properties = [
        "name", "warehouse_type", "warehouse_size", "wait_for_completion",
        "max_cluster_count", "min_cluster_count", "scaling_policy",
        "auto_suspend", "auto_resume", "initially_suspended",
        "resource_monitor", "comment", "enable_query_acceleration",
        "query_acceleration_max_scale_factor", "max_concurrency_level",
        "statement_queued_timeout_in_seconds", "statement_timeout_in_seconds",
        "type", "size", "state", "started_clusters", "running", "queued",
        "is_default", "is_current", "available", "provisioning", "quiescing",
        "other", "created_on", "resumed_on", "updated_on", "owner", "budget",
        "kind", "owner_role_type"
    ]

    @field_validator('name')
    def name_validate_regular_expression(cls, v):

        if not re.match(r"""^\"([^\"]|\"\")+\"|[a-zA-Z_][a-zA-Z0-9_$]*$""", v):
            raise ValueError(
                r"""must validate the regular expression /^"([^"]|"")+"|[a-zA-Z_][a-zA-Z0-9_$]*$/"""
            )
        return v

    @field_validator('wait_for_completion')
    def wait_for_completion_validate_enum(cls, v):

        if v is None:
            return v
        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ()")
        return v

    @field_validator('auto_resume')
    def auto_resume_validate_enum(cls, v):

        if v is None:
            return v
        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ()")
        return v

    @field_validator('initially_suspended')
    def initially_suspended_validate_enum(cls, v):

        if v is None:
            return v
        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ()")
        return v

    @field_validator('resource_monitor')
    def resource_monitor_validate_regular_expression(cls, v):

        if v is None:
            return v
        if not re.match(r"""^\"([^\"]|\"\")+\"|[a-zA-Z_][a-zA-Z0-9_$]*$""", v):
            raise ValueError(
                r"""must validate the regular expression /^"([^"]|"")+"|[a-zA-Z_][a-zA-Z0-9_$]*$/"""
            )
        return v

    @field_validator('enable_query_acceleration')
    def enable_query_acceleration_validate_enum(cls, v):

        if v is None:
            return v
        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ()")
        return v

    class Config:
        populate_by_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Warehouse:
        """Create an instance of Warehouse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = dict(
            self._iter(to_dict=True,
                       by_alias=True,
                       exclude={
                           "state",
                           "started_clusters",
                           "running",
                           "queued",
                           "is_default",
                           "is_current",
                           "available",
                           "provisioning",
                           "quiescing",
                           "other",
                           "created_on",
                           "resumed_on",
                           "updated_on",
                           "owner",
                           "budget",
                           "kind",
                           "owner_role_type",
                       },
                       exclude_none=True))

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Warehouse:
        """Create an instance of Warehouse from a dict"""

        if obj is None:
            return None

        if type(obj) is not dict:
            return Warehouse.parse_obj(obj)

        _obj = Warehouse.parse_obj({
            "name":
            obj.get("name"),
            "warehouse_type":
            obj.get("warehouse_type"),
            "warehouse_size":
            obj.get("warehouse_size"),
            "wait_for_completion":
            obj.get("wait_for_completion"),
            "max_cluster_count":
            obj.get("max_cluster_count"),
            "min_cluster_count":
            obj.get("min_cluster_count"),
            "scaling_policy":
            obj.get("scaling_policy"),
            "auto_suspend":
            obj.get("auto_suspend"),
            "auto_resume":
            obj.get("auto_resume"),
            "initially_suspended":
            obj.get("initially_suspended"),
            "resource_monitor":
            obj.get("resource_monitor"),
            "comment":
            obj.get("comment"),
            "enable_query_acceleration":
            obj.get("enable_query_acceleration"),
            "query_acceleration_max_scale_factor":
            obj.get("query_acceleration_max_scale_factor"),
            "max_concurrency_level":
            obj.get("max_concurrency_level"),
            "statement_queued_timeout_in_seconds":
            obj.get("statement_queued_timeout_in_seconds"),
            "statement_timeout_in_seconds":
            obj.get("statement_timeout_in_seconds"),
            "type":
            obj.get("type"),
            "size":
            obj.get("size"),
            "state":
            obj.get("state"),
            "started_clusters":
            obj.get("started_clusters"),
            "running":
            obj.get("running"),
            "queued":
            obj.get("queued"),
            "is_default":
            obj.get("is_default"),
            "is_current":
            obj.get("is_current"),
            "available":
            obj.get("available"),
            "provisioning":
            obj.get("provisioning"),
            "quiescing":
            obj.get("quiescing"),
            "other":
            obj.get("other"),
            "created_on":
            obj.get("created_on"),
            "resumed_on":
            obj.get("resumed_on"),
            "updated_on":
            obj.get("updated_on"),
            "owner":
            obj.get("owner"),
            "budget":
            obj.get("budget"),
            "kind":
            obj.get("kind"),
            "owner_role_type":
            obj.get("owner_role_type"),
        })

        return _obj


from typing import Optional, List, Dict


class WarehouseModel():

    def __init__(
        self,
        name: str,
        # optional properties
        warehouse_type: Optional[str] = None,
        warehouse_size: Optional[str] = None,
        wait_for_completion: Optional[str] = None,
        max_cluster_count: Optional[int] = None,
        min_cluster_count: Optional[int] = None,
        scaling_policy: Optional[str] = None,
        auto_suspend: Optional[int] = None,
        auto_resume: Optional[str] = None,
        initially_suspended: Optional[str] = None,
        resource_monitor: Optional[str] = None,
        comment: Optional[str] = None,
        enable_query_acceleration: Optional[str] = None,
        query_acceleration_max_scale_factor: Optional[int] = None,
        max_concurrency_level: Optional[int] = None,
        statement_queued_timeout_in_seconds: Optional[int] = None,
        statement_timeout_in_seconds: Optional[int] = None,
        type: Optional[str] = None,
        size: Optional[str] = None,
        state: Optional[str] = None,
        started_clusters: Optional[int] = None,
        running: Optional[int] = None,
        queued: Optional[int] = None,
        is_default: Optional[bool] = None,
        is_current: Optional[bool] = None,
        available: Optional[str] = None,
        provisioning: Optional[str] = None,
        quiescing: Optional[str] = None,
        other: Optional[str] = None,
        created_on: Optional[datetime] = None,
        resumed_on: Optional[datetime] = None,
        updated_on: Optional[datetime] = None,
        owner: Optional[str] = None,
        budget: Optional[str] = None,
        kind: Optional[str] = None,
        owner_role_type: Optional[str] = None,
    ):

        self.name = name
        self.warehouse_type = warehouse_type
        self.warehouse_size = warehouse_size
        self.wait_for_completion = wait_for_completion
        self.max_cluster_count = max_cluster_count
        self.min_cluster_count = min_cluster_count
        self.scaling_policy = scaling_policy
        self.auto_suspend = auto_suspend
        self.auto_resume = auto_resume
        self.initially_suspended = initially_suspended
        self.resource_monitor = resource_monitor
        self.comment = comment
        self.enable_query_acceleration = enable_query_acceleration
        self.query_acceleration_max_scale_factor = query_acceleration_max_scale_factor
        self.max_concurrency_level = max_concurrency_level
        self.statement_queued_timeout_in_seconds = statement_queued_timeout_in_seconds
        self.statement_timeout_in_seconds = statement_timeout_in_seconds
        self.type = type
        self.size = size
        self.state = state
        self.started_clusters = started_clusters
        self.running = running
        self.queued = queued
        self.is_default = is_default
        self.is_current = is_current
        self.available = available
        self.provisioning = provisioning
        self.quiescing = quiescing
        self.other = other
        self.created_on = created_on
        self.resumed_on = resumed_on
        self.updated_on = updated_on
        self.owner = owner
        self.budget = budget
        self.kind = kind
        self.owner_role_type = owner_role_type

    __properties = [
        "name", "warehouse_type", "warehouse_size", "wait_for_completion",
        "max_cluster_count", "min_cluster_count", "scaling_policy",
        "auto_suspend", "auto_resume", "initially_suspended",
        "resource_monitor", "comment", "enable_query_acceleration",
        "query_acceleration_max_scale_factor", "max_concurrency_level",
        "statement_queued_timeout_in_seconds", "statement_timeout_in_seconds",
        "type", "size", "state", "started_clusters", "running", "queued",
        "is_default", "is_current", "available", "provisioning", "quiescing",
        "other", "created_on", "resumed_on", "updated_on", "owner", "budget",
        "kind", "owner_role_type"
    ]

    def _to_model(self):
        return Warehouse(
            name=self.name,
            warehouse_type=self.warehouse_type,
            warehouse_size=self.warehouse_size,
            wait_for_completion=self.wait_for_completion,
            max_cluster_count=self.max_cluster_count,
            min_cluster_count=self.min_cluster_count,
            scaling_policy=self.scaling_policy,
            auto_suspend=self.auto_suspend,
            auto_resume=self.auto_resume,
            initially_suspended=self.initially_suspended,
            resource_monitor=self.resource_monitor,
            comment=self.comment,
            enable_query_acceleration=self.enable_query_acceleration,
            query_acceleration_max_scale_factor=self.
            query_acceleration_max_scale_factor,
            max_concurrency_level=self.max_concurrency_level,
            statement_queued_timeout_in_seconds=self.
            statement_queued_timeout_in_seconds,
            statement_timeout_in_seconds=self.statement_timeout_in_seconds,
            type=self.type,
            size=self.size,
            state=self.state,
            started_clusters=self.started_clusters,
            running=self.running,
            queued=self.queued,
            is_default=self.is_default,
            is_current=self.is_current,
            available=self.available,
            provisioning=self.provisioning,
            quiescing=self.quiescing,
            other=self.other,
            created_on=self.created_on,
            resumed_on=self.resumed_on,
            updated_on=self.updated_on,
            owner=self.owner,
            budget=self.budget,
            kind=self.kind,
            owner_role_type=self.owner_role_type,
        )

    @classmethod
    def _from_model(cls, model) -> WarehouseModel:
        return WarehouseModel(
            name=model.name,
            warehouse_type=model.warehouse_type,
            warehouse_size=model.warehouse_size,
            wait_for_completion=model.wait_for_completion,
            max_cluster_count=model.max_cluster_count,
            min_cluster_count=model.min_cluster_count,
            scaling_policy=model.scaling_policy,
            auto_suspend=model.auto_suspend,
            auto_resume=model.auto_resume,
            initially_suspended=model.initially_suspended,
            resource_monitor=model.resource_monitor,
            comment=model.comment,
            enable_query_acceleration=model.enable_query_acceleration,
            query_acceleration_max_scale_factor=model.
            query_acceleration_max_scale_factor,
            max_concurrency_level=model.max_concurrency_level,
            statement_queued_timeout_in_seconds=model.
            statement_queued_timeout_in_seconds,
            statement_timeout_in_seconds=model.statement_timeout_in_seconds,
            type=model.type,
            size=model.size,
            state=model.state,
            started_clusters=model.started_clusters,
            running=model.running,
            queued=model.queued,
            is_default=model.is_default,
            is_current=model.is_current,
            available=model.available,
            provisioning=model.provisioning,
            quiescing=model.quiescing,
            other=model.other,
            created_on=model.created_on,
            resumed_on=model.resumed_on,
            updated_on=model.updated_on,
            owner=model.owner,
            budget=model.budget,
            kind=model.kind,
            owner_role_type=model.owner_role_type,
        )

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        return self._to_model().to_dict()

    @classmethod
    def from_dict(cls, obj: dict) -> WarehouseModel:
        """Create an instance of Warehouse from a dict"""
        return cls._from_model(Warehouse.from_dict(obj))


Warehouse._model_class = WarehouseModel

# coding: utf-8
"""
    Snowflake Database API

    The Snowflake Database API is a REST API that you can use to access, update, and perform certain actions on Database resource in Snowflake.  # noqa: E501

    The version of the OpenAPI document: 0.0.1
    Contact: support@snowflake.com
    Generated by: https://openapi-generator.tech

    Do not edit this file manually.
"""

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from typing import Union

from datetime import datetime

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator

from typing import Any, ClassVar, Dict, List, Optional

from typing_extensions import Annotated


class Database(BaseModel):

    created_on: Optional[datetime] = None

    name: Annotated[str, Field(strict=True)]

    kind: Optional[StrictStr] = 'PERMANENT'

    is_default: Optional[StrictBool] = None

    is_current: Optional[StrictBool] = None

    origin: Optional[StrictStr] = None

    owner: Optional[StrictStr] = None

    comment: Optional[StrictStr] = None

    options: Optional[StrictStr] = None

    retention_time: Optional[StrictInt] = None

    dropped_on: Optional[datetime] = None

    budget: Optional[StrictStr] = None

    owner_role_type: Optional[StrictStr] = None

    data_retention_time_in_days: Optional[StrictInt] = None

    default_ddl_collation: Optional[StrictStr] = None

    log_level: Optional[StrictStr] = None

    max_data_extension_time_in_days: Optional[StrictInt] = None

    suspend_task_after_num_failures: Optional[StrictInt] = None

    trace_level: Optional[StrictStr] = None

    user_task_managed_initial_warehouse_size: Optional[StrictStr] = None

    user_task_timeout_ms: Optional[StrictInt] = None

    __properties = [
        "created_on", "name", "kind", "is_default", "is_current", "origin",
        "owner", "comment", "options", "retention_time", "dropped_on",
        "budget", "owner_role_type", "data_retention_time_in_days",
        "default_ddl_collation", "log_level",
        "max_data_extension_time_in_days", "suspend_task_after_num_failures",
        "trace_level", "user_task_managed_initial_warehouse_size",
        "user_task_timeout_ms"
    ]

    @field_validator('name')
    def name_validate_regular_expression(cls, v):

        if not re.match(r"""^\"([^\"]|\"\")+\"|[a-zA-Z_][a-zA-Z0-9_$]*$""", v):
            raise ValueError(
                r"""must validate the regular expression /^"([^"]|"")+"|[a-zA-Z_][a-zA-Z0-9_$]*$/"""
            )
        return v

    @field_validator('kind')
    def kind_validate_enum(cls, v):

        if v is None:
            return v
        if v not in ('PERMANENT', 'TRANSIENT'):
            raise ValueError("must validate the enum values ()")
        return v

    class Config:
        populate_by_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Database:
        """Create an instance of Database from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = dict(
            self._iter(to_dict=True,
                       by_alias=True,
                       exclude={
                           "created_on",
                           "is_default",
                           "is_current",
                           "origin",
                           "owner",
                           "options",
                           "retention_time",
                           "dropped_on",
                           "budget",
                           "owner_role_type",
                       },
                       exclude_none=True))

        # set to None if dropped_on (nullable) is None
        if self.dropped_on is None:
            _dict['dropped_on'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Database:
        """Create an instance of Database from a dict"""

        if obj is None:
            return None

        if type(obj) is not dict:
            return Database.parse_obj(obj)

        _obj = Database.parse_obj({
            "created_on":
            obj.get("created_on"),
            "name":
            obj.get("name"),
            "kind":
            obj.get("kind") if obj.get("kind") is not None else 'PERMANENT',
            "is_default":
            obj.get("is_default"),
            "is_current":
            obj.get("is_current"),
            "origin":
            obj.get("origin"),
            "owner":
            obj.get("owner"),
            "comment":
            obj.get("comment"),
            "options":
            obj.get("options"),
            "retention_time":
            obj.get("retention_time"),
            "dropped_on":
            obj.get("dropped_on"),
            "budget":
            obj.get("budget"),
            "owner_role_type":
            obj.get("owner_role_type"),
            "data_retention_time_in_days":
            obj.get("data_retention_time_in_days"),
            "default_ddl_collation":
            obj.get("default_ddl_collation"),
            "log_level":
            obj.get("log_level"),
            "max_data_extension_time_in_days":
            obj.get("max_data_extension_time_in_days"),
            "suspend_task_after_num_failures":
            obj.get("suspend_task_after_num_failures"),
            "trace_level":
            obj.get("trace_level"),
            "user_task_managed_initial_warehouse_size":
            obj.get("user_task_managed_initial_warehouse_size"),
            "user_task_timeout_ms":
            obj.get("user_task_timeout_ms"),
        })

        return _obj


from typing import Optional, List, Dict


class DatabaseModel():

    def __init__(
        self,
        name: str,
        # optional properties
        created_on: Optional[datetime] = None,
        kind: Optional[str] = 'PERMANENT',
        is_default: Optional[bool] = None,
        is_current: Optional[bool] = None,
        origin: Optional[str] = None,
        owner: Optional[str] = None,
        comment: Optional[str] = None,
        options: Optional[str] = None,
        retention_time: Optional[int] = None,
        dropped_on: Optional[datetime] = None,
        budget: Optional[str] = None,
        owner_role_type: Optional[str] = None,
        data_retention_time_in_days: Optional[int] = None,
        default_ddl_collation: Optional[str] = None,
        log_level: Optional[str] = None,
        max_data_extension_time_in_days: Optional[int] = None,
        suspend_task_after_num_failures: Optional[int] = None,
        trace_level: Optional[str] = None,
        user_task_managed_initial_warehouse_size: Optional[str] = None,
        user_task_timeout_ms: Optional[int] = None,
    ):

        self.created_on = created_on
        self.name = name
        self.kind = kind
        self.is_default = is_default
        self.is_current = is_current
        self.origin = origin
        self.owner = owner
        self.comment = comment
        self.options = options
        self.retention_time = retention_time
        self.dropped_on = dropped_on
        self.budget = budget
        self.owner_role_type = owner_role_type
        self.data_retention_time_in_days = data_retention_time_in_days
        self.default_ddl_collation = default_ddl_collation
        self.log_level = log_level
        self.max_data_extension_time_in_days = max_data_extension_time_in_days
        self.suspend_task_after_num_failures = suspend_task_after_num_failures
        self.trace_level = trace_level
        self.user_task_managed_initial_warehouse_size = user_task_managed_initial_warehouse_size
        self.user_task_timeout_ms = user_task_timeout_ms

    __properties = [
        "created_on", "name", "kind", "is_default", "is_current", "origin",
        "owner", "comment", "options", "retention_time", "dropped_on",
        "budget", "owner_role_type", "data_retention_time_in_days",
        "default_ddl_collation", "log_level",
        "max_data_extension_time_in_days", "suspend_task_after_num_failures",
        "trace_level", "user_task_managed_initial_warehouse_size",
        "user_task_timeout_ms"
    ]

    def _to_model(self):
        return Database(
            created_on=self.created_on,
            name=self.name,
            kind=self.kind,
            is_default=self.is_default,
            is_current=self.is_current,
            origin=self.origin,
            owner=self.owner,
            comment=self.comment,
            options=self.options,
            retention_time=self.retention_time,
            dropped_on=self.dropped_on,
            budget=self.budget,
            owner_role_type=self.owner_role_type,
            data_retention_time_in_days=self.data_retention_time_in_days,
            default_ddl_collation=self.default_ddl_collation,
            log_level=self.log_level,
            max_data_extension_time_in_days=self.
            max_data_extension_time_in_days,
            suspend_task_after_num_failures=self.
            suspend_task_after_num_failures,
            trace_level=self.trace_level,
            user_task_managed_initial_warehouse_size=self.
            user_task_managed_initial_warehouse_size,
            user_task_timeout_ms=self.user_task_timeout_ms,
        )

    @classmethod
    def _from_model(cls, model) -> DatabaseModel:
        return DatabaseModel(
            created_on=model.created_on,
            name=model.name,
            kind=model.kind,
            is_default=model.is_default,
            is_current=model.is_current,
            origin=model.origin,
            owner=model.owner,
            comment=model.comment,
            options=model.options,
            retention_time=model.retention_time,
            dropped_on=model.dropped_on,
            budget=model.budget,
            owner_role_type=model.owner_role_type,
            data_retention_time_in_days=model.data_retention_time_in_days,
            default_ddl_collation=model.default_ddl_collation,
            log_level=model.log_level,
            max_data_extension_time_in_days=model.
            max_data_extension_time_in_days,
            suspend_task_after_num_failures=model.
            suspend_task_after_num_failures,
            trace_level=model.trace_level,
            user_task_managed_initial_warehouse_size=model.
            user_task_managed_initial_warehouse_size,
            user_task_timeout_ms=model.user_task_timeout_ms,
        )

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        return self._to_model().to_dict()

    @classmethod
    def from_dict(cls, obj: dict) -> DatabaseModel:
        """Create an instance of Database from a dict"""
        return cls._from_model(Database.from_dict(obj))


Database._model_class = DatabaseModel
